/*Copyright 2012 Jean-Louis PASTUREL **   Licensed under the Apache License, Version 2.0 (the "License");*  you may not use this file except in compliance with the License.*  You may obtain a copy of the License at**       http://www.apache.org/licenses/LICENSE-2.0**   Unless required by applicable law or agreed to in writing, software*  distributed under the License is distributed on an "AS IS" BASIS,*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*   See the License for the specific language governing permissions and*  limitations under the License.*/package jlp.perf.aspects.concreteAspects;import java.io.File;import java.io.PrintWriter;import java.io.StringWriter;import java.sql.Statement;import java.text.DecimalFormat;import java.text.DecimalFormatSymbols;import java.util.Calendar;import java.util.Locale;import java.util.Properties;import java.util.WeakHashMap;import java.util.regex.Matcher;import java.util.regex.Pattern;import jlp.perf.aspects.abstractAspects.Trace;public aspect ConcreteSqlStatementsThrowingException {	private int countConnexions = 0;	private static String fileTrace = "";	private static boolean stripBeforeWhereBool = false;	private static int longMaxReq = 0;	private static Trace outSqlStatementDurations;	private static String regexpPattern = "";	private static Properties props;	private static long rank = 0;	private static String dirLogs, sep = ";";	private static WeakHashMap<Statement, String> statementSql = new WeakHashMap<Statement, String>();	private static DecimalFormat df = new DecimalFormat("#0.000",			new DecimalFormatSymbols(Locale.ENGLISH));	private static DecimalFormat dfPercent = new DecimalFormat("#0.0",			new DecimalFormatSymbols(Locale.ENGLISH));	private static boolean boolPattern = false;	private static boolean boolStackTrace = true;	private static boolean boolBindParameters = true;	static {		Locale.setDefault(Locale.ENGLISH);		props = jlp.perf.aspects.abstractAspects.AspectsPerfProperties.aspectsPerfProperties;		if (props.containsKey("aspectsPerf.default.sep")) {			sep = props.getProperty("aspectsPerf.default.sep");		}		if (props.containsKey("aspectsPerf.default.dirLogs")) {			dirLogs = props.getProperty("aspectsPerf.default.dirLogs");			if (!dirLogs.endsWith(File.separator)) {				dirLogs += File.separator;			}		} else {			dirLogs = "";		}		System.out				.println("Creation aspect ConcreteSqlStatementsThrowingException ");		if (props				.containsKey("jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.filelogs")) {			fileTrace = dirLogs					+ props.getProperty("jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.filelogs");		} else {			fileTrace = props.getProperty("aspectsPerf.default.filelogs");		}		regexpPattern = props				.getProperty(						"jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.regexpPattern",						"");		if (regexpPattern.length() > 3) {			boolPattern = true;		}		if (props				.containsKey("jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.stripBeforeWhereBool")) {			if (props					.getProperty(							"jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.stripBeforeWhereBool")					.equals("true"))			{				stripBeforeWhereBool = true;			}		}		if (props				.containsKey("jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.longMaxReq")) {			longMaxReq = Integer					.parseInt(props							.getProperty("jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.longMaxReq"));		}		boolStackTrace = Boolean				.parseBoolean(props						.getProperty(								"jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.boolStackTrace",								"true"));		boolBindParameters = Boolean				.parseBoolean(props						.getProperty(								"jlp.perf.aspects.concreteAspects.ConcreteSqlStatementsThrowingException.boolBindParameters",								"true"));		outSqlStatementDurations = new Trace("####time" + sep + "typeStatement"				+ sep + "SQL" + sep + "Exception" + sep + "rank\n", fileTrace);		// outSqlStatementDurations.append(new		// StringBuilder("####time;typeStatement;SQL;rank;duree \n").toString());	}	/** Matches any execution of a JDBC statement */	// public pointcut statementImpl() : !execution(public *	// java.sql.PreparedStatement.*(..));	public final pointcut statementExec(java.sql.PreparedStatement statement) : 		execution(public * java.sql.PreparedStatement.execute*(..))   && this(statement)   ;	/**	 * Call to create a Statement.	 * 	 * @param connection	 *            the connection called to create the statement, which is bound	 *            to track the statement's origin	 */	public final pointcut callCreatePreparedStatement(String sql): 		execution(java.sql.PreparedStatement java.sql.Connection+.prepare*(String, ..))           && args(sql, ..);	after(String sql) returning (java.sql.PreparedStatement statement):    	callCreatePreparedStatement( sql)    	{		synchronized (ConcreteSqlStatementsThrowingException.this) {			if (!statementSql.containsKey(statement) && null != sql					&& sql.trim().length() > 1)				statementSql.put(statement, sql);		}	}	after(java.sql.Statement statement) throwing(java.sql.SQLException ex):  statementExec(statement)      {		synchronized (ConcreteSqlStatementsThrowingException.this) {			// Sauver le sql			String sqlStr = "No Sql detected";			String errorSQL = "";			// Object retour = proceed(statement);			if (statementSql.containsKey(statement)) {				if (boolBindParameters) {					// sqlStr=statementSql.get(statement);					sqlStr = statement.toString();				} else {					sqlStr = statementSql.get(statement);				}			}			// Traitement de la regexp			if (boolStackTrace) {				errorSQL = new StringBuilder("SQLState = ")						.append(ex.getSQLState()).append(" : ")						.append("ErrorCode = ").append(ex.getErrorCode())						.append(" : ").append(ex.getMessage())						.append(" StackTrace= ").append(stack2string(ex))						.toString();			} else {				errorSQL = new StringBuilder("SQLState = ")						.append(ex.getSQLState()).append(" : ")						.append("ErrorCode = ").append(ex.getErrorCode())						.append(" : ").append(ex.getMessage()).toString();			}			// System.out.println("err="+err);			if (boolPattern) {				// System.out.println("passage dans boolPattern=true");				Pattern pat = Pattern.compile(regexpPattern);				Matcher match = pat.matcher(errorSQL);				if (match.find()) {					// System.out.println("passage dans boolPattern=true et on matche");					if (longMaxReq > 0 && errorSQL.length() > longMaxReq)						errorSQL = errorSQL.substring(0, longMaxReq);				} else {					return;				}			} else {				if (longMaxReq > 0 && errorSQL.length() > longMaxReq)					errorSQL = errorSQL.substring(0, longMaxReq);			}			rank++;			if (stripBeforeWhereBool) {				sqlStr = stripAfterWhere(sqlStr);			}			// String sql=stripAfterWhere((String)statementSql.get(statement));			if (longMaxReq > 0 && sqlStr.length() > longMaxReq) {				sqlStr = sqlStr.substring(0, longMaxReq);			}			// Remplacement des sauts de lignes eventuels			sqlStr = sqlStr.replaceAll("\\r*\\n+\\r*", " | ");			errorSQL = errorSQL.replaceAll("\\r*\\n+\\r*", " | ");			outSqlStatementDurations.append(new StringBuilder(					outSqlStatementDurations.getSdf().format(							Calendar.getInstance().getTime())).append(sep)					.append(thisJoinPoint.getThis().getClass().getSimpleName())					.append(sep)					// .append(thisJoinPoint.getThis().getClass().getSimpleName()).append(" : ")					.append(sqlStr).append(sep).append(Long.toString(rank))					.append(sep).append(errorSQL).append("\n").toString());		}	}	/**	 * To group sensibly and to avoid recording sensitive data, I don't record	 * the where clause (only used for dynamic SQL since parameters aren't	 * included in prepared statements)	 * 	 * @return subset of passed SQL up to the where clause	 */	public final static String stripAfterWhere(String sql) {		for (int i = 0; i < sql.length() - 4; i++) {			if (sql.charAt(i) == 'w' || sql.charAt(i) == 'W') {				if (sql.substring(i + 1, i + 5).equalsIgnoreCase("here")) {					sql = sql.substring(0, i);				}			}		}		return sql;	}	public static String stack2string(Exception e) {		try {			StringWriter sw = new StringWriter();			PrintWriter pw = new PrintWriter(sw);			e.printStackTrace(pw);			return sw.toString();		} catch (Exception e2) {			return "bad stack2string";		}	}	//	// private Map statementFabric=new WeakIdentityHashMap();}